// Generated by {{devName}}

import { Test, TestingModule } from '@nestjs/testing';
import { AppModule } from '../../../src/app.module';
import { callGraphQL, initApp, expectError, callLoginUser } from '../../common/utils';
import { HttpStatus } from '@nestjs/common';
import { DataSource } from 'typeorm';
import TestData from '../../common/data';
import { initializeTransactionalContext } from 'typeorm-transactional';
import { convertDate } from '../../common/datetime';
{{importEntity}}

describe('Test api {{apiName}}', () => {
  let app: any,
    con: DataSource,
    loginUserInfo = {
      auth: {
        accessToken: '',
      },
    };

  const userData = {
    id: 1,
    userName: 'unit_test',
    // Raw pwd 123456aA@
    password: '$2a$12$4cNkcbo7sTqW74I5KY/YVe36DjoMLH74oSxat6zyrF.VfUmqZNGwy',
    email: 'unit_test@gmail.com',
    gender: 'male',
  };

  const mutation = `
    mutation {{apiName}}($params: {{requestParam}}!) {
      {{apiName}}(params: $params) {
        data {
          {{outputAdd}}
        }
      }
    }
  `;

  beforeAll(async () => {
    try {
      {{transaction}}

      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();
      app = await initApp(moduleFixture);
      con = app.get(DataSource);

      await TestData.saveUserInfo(con, userData);

      // Login user to get valid access token
      loginUserInfo = await callLoginUser(app);
    } catch (error) {
      console.error('Unit test {{apiName}} error', error);
      throw new Error(error);
    }
  });

  afterAll(async () => {
    try {
      await TestData.deleteUserInfo(con, { id: userData.id });
      // Close app
      await app.close();
    } catch (error) {
      console.error('Unit test {{apiName}} error', error);
      throw new Error(error);
    }
  });

  it('Test no authorization', async () => {
    const body = await callGraphQL(app, mutation, HttpStatus.UNAUTHORIZED, {
      params: {{params}},
    });
    expectError(body, ['Unauthorized']);
  });
  it('Test invalid authorization', async () => {
    const body = await callGraphQL(app, mutation, HttpStatus.UNAUTHORIZED,
      {
        params: {{params}},
      },
      {
        authorization: 'Bearer invalid token',
      },
    );
    expectError(body, ['Unauthorized']);
  });
  it('Test params empty', async () => {
    const body = await callGraphQL(app, mutation, HttpStatus.BAD_REQUEST);
    // Check return value
    expectError(body, ['was not provided']);
  });

  // Do not delete this comment
  // Append test case in this place

  it('Test add data success', async () => {
    {{otherSaveInfo}}

    const params = {{params}};
    const body = await callGraphQL(
      app,
      mutation,
      HttpStatus.OK,
      {
        params: params,
      },
      {
        authorization: 'Bearer ' + loginUserInfo.auth.accessToken,
      }
    );
    // Check return value
    let result = body.data.{{apiName}}.data,
      id = result.id;
    // Because id is increased automatically
    delete result['id'];
    {{deleteInfo}}
    checkData(result, {{expectedResult}});
  });
});

/**
 * Check data
 * @param result
 * @param actualList
 */
function checkData(info: any, actualInfo: any) {
  for (const key in info) {
    const expectedObj = info[key];
    if (typeof expectedObj === 'object') {
      if (Array.isArray(expectedObj)) {
        const actualArr = actualInfo[key];
        expectedObj.forEach((item, idx) => {
          for (const childKey in item) {
            if (childKey.indexOf('Date') > -1 || childKey.indexOf('date') > -1) {
              expect(convertDate(item[childKey])).toEqual(actualArr[idx][childKey]);
            } else {
              expect(item[childKey]).toEqual(actualArr[idx][childKey]);
            }
          }
        });
      } else {
        const actualObj = actualInfo[key];
        for (const childKey in expectedObj) {
          if (childKey.indexOf('Date') > -1 || childKey.indexOf('date') > -1) {
            expect(convertDate(expectedObj[childKey])).toEqual(actualObj[childKey]);
          } else {
            expect(expectedObj[childKey]).toEqual(actualObj[childKey]);
          }
        }
      }
    } else {
      if (key.indexOf('Date') > -1 || key.indexOf('date') > -1) {
        expect(convertDate(expectedObj)).toEqual(actualInfo[key]);
      } else {
        expect(expectedObj).toEqual(actualInfo[key]);
      }
    }
  }
}
