// Generated by ThanhLD

import { BadRequestException, Injectable } from '@nestjs/common';
import { ForbiddenError } from 'apollo-server-core';
import { Transactional } from 'typeorm-transactional';
import _ = require('lodash');
import { ProjectsRepository } from '../../repositories/projects.repository';
import { ProjectsEntity } from '../../entities/projects.entity';
import { UsersEntity } from '../../entities/users.entity';
import { ProjectsSkillsEntity } from '../../entities/projects-skills.entity';
import { SkillsEntity } from '../../entities/skills.entity';
import { UsersService } from '../users/users.service';
import { UsersRepository } from '../../repositories/users.repository';
import { ProjectsSkillsRepository } from '../../repositories/projects-skills.repository';
import { SkillsRepository } from '../../repositories/skills.repository';

@Injectable()
export class ProjectsService {
  private entityAlias: string;
  private userAlias: string;
  private projectsSkillAlias: string;
  private skillAlias: string;

  constructor(
    private projectsRepository: ProjectsRepository,
    private usersService: UsersService,
    private usersRepository: UsersRepository,
    private projectsSkillsRepository: ProjectsSkillsRepository,
    private skillsRepository: SkillsRepository
  ) {
    this.entityAlias = ProjectsEntity.name;
    this.userAlias = UsersEntity.name;
    this.projectsSkillAlias = ProjectsSkillsEntity.name;
    this.skillAlias = SkillsEntity.name;
  }

  // Do not delete this comment
  // Append code in this place
  @Transactional()
  /**
   * @author: ThanhLD
   * @date: 2023-02-07 11:14:07
   * Method deleteProject
   * Delete record by id
   * @param id: number
   * @param user: UsersEntity
   * @returns boolean
   */
  async deleteProject(id: number, user: UsersEntity) {
    const data = { result: false };
    const project = await this.projectsRepository.findOne({
      where: { id },
    });
    if (_.isEmpty(project)) {
      throw new BadRequestException('project not found.');
    }

    await this.projectsSkillsRepository.delete({ project: { id: id } });

    const result = await this.projectsRepository.delete({ id });
    if (result.affected && result.affected > 0) {
      data.result = true;
    } else {
      data.result = false;
    }

    return data;
  }

  @Transactional()
  /**
   * @author: ThanhLD
   * @date: 2023-02-07 10:26:17
   * Method addProject
   * Add new record
   * @param owner: UsersEntity
   * @param params: {url: string, comment:string}
   * @returns new inserted record
   */
  async addProject(owner: UsersEntity, params) {
    try {
      const projectsObjEntity = new ProjectsEntity(params);

      const project = this.projectsRepository.create(projectsObjEntity);
      let response = await this.projectsRepository.save(project);
      if (params['skills']) {
        const existsSkills = await this.skillsRepository
          .createQueryBuilder()
          .where('id in (:...values)', { values: params['skills'] })
          .getMany();
        if (!existsSkills.length) {
          throw new BadRequestException('skills not found.');
        }
        const arrSkills = existsSkills.map((item: any) => {
          const savedObj = new ProjectsSkillsEntity();
          savedObj.project = response;
          savedObj.skill = item;
          return this.projectsSkillsRepository.create(savedObj);
        });
        if (arrSkills.length) {
          const resultSkills: any = await this.projectsSkillsRepository.save(arrSkills);
          response['skills'] = resultSkills.map((item) => {
            return item['skill'];
          });
        }
      }

      return response;
    } catch (error) {
      throw new BadRequestException(error);
    }
  }

  /**
   * @author: ThanhLD
   * @date: 2023-02-07 08:51:29
   * Method getProjects
   * Get list
   * @param pager: {limit: number, offset?: number, page?: number, isTakeAll?: boolean}
   * @param filterConditions: JSON Object
   * @param orderConditions: JSON Object
   * @returns {data, paging}
   */
  async getProjects(pager, filterConditions: object = undefined, orderConditions: object = undefined) {
    const queryBuilder = this.projectsRepository
      .createQueryBuilder(this.entityAlias)
      .leftJoinAndSelect(`${this.entityAlias}.projectSkills`, this.projectsSkillAlias)
      .leftJoinAndMapMany(
        `${this.entityAlias}.skills`,
        SkillsEntity,
        this.skillAlias,
        `${this.projectsSkillAlias}.skill_id = ${this.skillAlias}.id`
      )

      .select([
        `${this.entityAlias}.id`,
        `${this.entityAlias}.projectCode`,
        `${this.entityAlias}.projectName`,
        `${this.entityAlias}.projectDescription`,
        `${this.entityAlias}.startDate`,
        `${this.entityAlias}.endDate`,
        `${this.skillAlias}.id`,
        `${this.skillAlias}.skillName`,
        `${this.skillAlias}.language`,
      ]);
    if (!_.isEmpty(filterConditions)) {
      // add filters condition here
    }
    if (!_.isEmpty(orderConditions)) {
      // add orders condition here
    }
    // pass final queryBuilder here to paging
    const [data, paging] = await queryBuilder.paginate(pager, filterConditions, orderConditions);
    // parse result as paging result
    return { data, paging };
  }
}
